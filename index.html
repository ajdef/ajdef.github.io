<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>FPGA Grid – merged tiles + expanding popup</title>
  <style>
    :root{
      --bg:#0b0f15; --ink:#e5e7eb; --stroke:#9ca3af; --hot:#111827;
      --tile:#fb923c; --dsp:#6aa9ff; --bram:#a78bfa; --io:#34d399;
      --wire:#94a3b8; --wire-hot:#f8fafc; --proj:#568d94; --rsch:#7458c2;
      --overlay-bg: rgba(4,7,12,.55);
      --flash:#84cc16;
    }
    html,body{margin:0;height:100%;background:#0b0f15;color:var(--ink);
      font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Inter,"Helvetica Neue",Arial}
    .wrap{max-width:860px;margin:0 auto;padding:24px 16px 40px; position: relative;}
    h1{margin:0 0 8px;font-size:20px;color:#cbd5e1}
    p.sub{margin:0 0 16px;color:#9aa6b2;font-size:13px}
    .tooltip{position:absolute;left:50%;top:8px;transform:translateX(-50%);
      background:rgba(255,255,255,.9);color:#111827;border-radius:10px;padding:6px 10px;
      font-size:12px;pointer-events:none;box-shadow:0 6px 18px rgba(0,0,0,.25)}
    a:focus{outline:2px solid #60a5fa;outline-offset:2px}

    /* Header row with right-aligned LEDs */
    .header-row{
      display:flex; align-items:center; justify-content:space-between;
      gap:12px; margin:0 0 8px;
    }
    .status-leds{
      display:inline-flex; align-items:center; gap:16px;
      background:#0b1224; border:1px solid #243044; border-radius:8px;
      padding:6px 10px; box-shadow:0 6px 18px rgba(0,0,0,.12) inset;
      font-size:12px; color:#cbd5e1; white-space:nowrap;
    }
    .status-led{ display:inline-flex; align-items:center; gap:6px; }
    .status-dot{
      width:10px; height:10px; border-radius:50%;
      border:1px solid #334155; box-shadow:0 0 0 rgba(0,0,0,0);
    }
    .status-dot.on{ box-shadow:0 0 10px currentColor; }

    /* Popup / overlay */
    .overlay { position: absolute; inset: 0; display: none; align-items: center; justify-content: center;
      background: var(--overlay-bg); backdrop-filter: blur(2px); z-index: 5; }
    .overlay.open { display: flex; }
    .popup { position: absolute; border-radius: 14px; background: #0f172a; color: #e2e8f0;
      box-shadow: 0 18px 60px rgba(0,0,0,.45), 0 2px 16px rgba(0,0,0,.35) inset; border: 1px solid #334155;
      overflow: hidden; transition: left .28s ease, top .28s ease, width .28s ease, height .28s ease, border-radius .28s ease, opacity .18s ease; }
    .popup-content { height: 100%; display: flex; flex-direction: column; }
    .popup-header { display: flex; align-items: center; justify-content: space-between;
      padding: 12px 14px; background: #0b1224; border-bottom: 1px solid #243044; font-weight: 600; }
    .popup-body { padding: 14px; overflow: auto; line-height: 1.5; font-size: 14px; display:flex; flex-direction:column; gap:12px; height:100%; }
    .close-btn { background: #131c33; color: #cbd5e1; border: 1px solid #334155; border-radius: 10px; padding: 6px 10px; cursor: pointer; }
    .close-btn:hover { background: #1b2643; }
    .tag { display:inline-block; padding:2px 8px; border-radius:999px; font-size:12px; border:1px solid #334155; background:#0b1224; margin-left:8px; color:#8fb4ff; }

    /* media wrappers */
    .fill { flex:1 1 auto; min-height:0; }
    .pdfWrap, .iframeWrap, .imgWrap { flex:1 1 auto; min-height:0; border:1px solid #243044; border-radius:10px; overflow:hidden; background:#0b1224; }
    .pdfWrap object, .iframeWrap iframe { width:100%; height:100%; border:0; }
    .imgWrap img { width:100%; height:100%; object-fit:contain; display:block; background:#0b1224; }

    /* Glow (wires + tiles) */
    .wire { transition: stroke .22s ease, stroke-width .22s ease, opacity .18s ease; }
    .wire--flash { filter: drop-shadow(0 0 8px rgba(132,204,22,.45)); }

    .wireHalo, .tileHalo { opacity: 0; filter: url(#softGlow); pointer-events:none; }
    .wireHalo.animate, .tileHalo.animate { animation: haloPulse 1200ms ease-out forwards; }

    @keyframes haloPulse { 0% {opacity:0;} 35% {opacity:.95;} 100% {opacity:0;} }
  </style>
</head>
<body>
  <div id="root"></div>

  <!-- React + ReactDOM + Babel -->
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <script type="text/babel">
    const {useMemo,useEffect,useRef,useState} = React;

    /* ===== Config ===== */
    const COVER_MODE  = "full";      // "full" | "ratio"
    const COVER_RATIO = 0.9;         // width ratio when COVER_MODE === "ratio"
    const HEIGHT_RATIO = COVER_RATIO; // default height ratio
    const FLASH_MS    = 1200;        // click highlight duration before popup
    const FLASH_MODE  = "gradient";  // "solid" | "random" | "gradient"

    /* --- Initial "wave draw" of traces --- */
    const WAVE_FROM_ID        = "About Me"; // origin tile
    const WAVE_START_DELAY_MS = 300;        // wait after mount
    const WAVE_RING_STEP_MS   = 160;        // delay per ring from origin
    const WAVE_DRAW_MS        = 600;        // duration each wire draws

    /* --- Post-wave global glow duration (matches CSS haloPulse) --- */
    const END_GLOW_MS = 1200;

    /* ===== Global scaling (tiles + gaps + label font) ===== */
    const SCALE      = 1.5;
    const BASE_SIZE  = 56;
    const BASE_GAP   = 14;
    const BASE_FONT  = 11;

    const size      = Math.round(BASE_SIZE * SCALE);
    const gap       = Math.round(BASE_GAP  * SCALE);
    const fontSize  = Math.max(10, Math.round(BASE_FONT * SCALE));

    /* margin so halos aren't clipped at edges */
    const PAD = 28;

    /* --- Text helpers (manual newline support) --- */
    function splitLines(label){ return String(label ?? "").split(/\r?\n/); }
    function Label({ t, x, y, tw, th, fontSize, opacity=1 }) {
      const lines = splitLines(t.label);
      const lineHeight = Math.round(fontSize * 1.2);
      const totalH = lineHeight * lines.length;
      const startY = y + (th - totalH)/2 + lineHeight*0.8;
      const cx = x + tw/2;
      return (
        <text x={cx} y={startY} textAnchor="middle" fontSize={fontSize} fill="#111827"
              style={{pointerEvents:"none",userSelect:"none"}} opacity={opacity}>
          {lines.map((ln,i)=>(<tspan key={i} x={cx} dy={i===0 ? 0 : lineHeight}>{ln}</tspan>))}
        </text>
      );
    }

    function pxOrPct(v, ref) {
      if (typeof v === "string" && v.endsWith("%")) return (parseFloat(v)/100) * ref;
      if (Number.isFinite(v)) return v;
      return 0;
    }

    /* --- Small LED panel component --- */
    function StatusLEDs({ busy }) {
      const busyColor = busy ? "#ef4444" : "#1f2937";   // red when ON, slate when OFF
      const doneColor = !busy ? "#22c55e" : "#1f2937";  // green when ON
      return (
        <div className="status-leds" aria-label="Status LEDs">
          <div className="status-led" aria-label={`Busy ${busy ? "on" : "off"}`}>
            <span className={`status-dot ${busy ? "on" : ""}`} style={{color:busyColor, background:busyColor}} />
            <span>BUSY</span>
          </div>
          <div className="status-led" aria-label={`Done ${!busy ? "on" : "off"}`}>
            <span className={`status-dot ${!busy ? "on" : ""}`} style={{color:doneColor, background:doneColor}} />
            <span>DONE</span>
          </div>
        </div>
      );
    }

    /* --- Wave helpers --- */
    function centerOf(t){
      const c = t.c + (t.spanC ?? 1)/2;
      const r = t.r + (t.spanR ?? 1)/2;
      return [c,r];
    }
    function ringFromTo(a,b){ return Math.max(Math.abs(a[0]-b[0]), Math.abs(a[1]-b[1])); } // chebyshev
    function pathLen(pts){
      let L=0; for(let i=1;i<pts.length;i++){
        const dx=pts[i][0]-pts[i-1][0], dy=pts[i][1]-pts[i-1][1];
        L += Math.hypot(dx,dy);
      } return L;
    }
    function easeInOut(t){ return 0.5*(1-Math.cos(Math.PI*Math.max(0,Math.min(1,t)))); }

    /* ---- Popup content renderer (per-tile) ---- */
    function PopupBody({ tile }) {
      const c = tile?.content;

      if (!c) {
        return (
          <div className="popup-body">
            <p><strong>ID:</strong> {tile.id}</p>
            <p><strong>Grid position:</strong> r{tile.r}, c{tile.c} {tile.spanR||tile.spanC ? `(span ${tile.spanR||1}×${tile.spanC||1})` : ""}</p>
            <p>No custom content provided yet.</p>
          </div>
        );
      }

      if (c.type === "pdf") {
        return (
          <div className="popup-body">
            {c.title && <h3 style={{margin:"0 0 6px"}}>{c.title}</h3>}
            <div className="pdfWrap fill">
              <object data={c.src} type="application/pdf">
                <div style={{padding:12}}>
                  Your browser can’t display embedded PDFs here.
                  <a href={c.src} target="_blank" rel="noreferrer" style={{marginLeft:8}}>Open the PDF</a>
                </div>
              </object>
            </div>
          </div>
        );
      }

      if (c.type === "img") {
        return (
          <div className="popup-body">
            {c.caption && <h3 style={{margin:"0 0 6px"}}>{c.caption}</h3>}
            <div className="imgWrap fill"><img src={c.src} alt={c.alt||""}/></div>
          </div>
        );
      }

      if (c.type === "list") {
        return (
          <div className="popup-body">
            {c.title && <h3 style={{margin:"0 0 6px"}}>{c.title}</h3>}
            <ul style={{margin:"0 0 8px 18px"}}>
              {c.items?.map((it,i)=>(<li key={i}>{it}</li>))}
            </ul>
            {c.note && <p style={{opacity:.8}}>{c.note}</p>}
          </div>
        );
      }

      if (c.type === "html") {
        return (
          <div className="popup-body">
            <div dangerouslySetInnerHTML={{__html:c.html}} className="fill" />
          </div>
        );
      }

      if (c.type === "jsx" && typeof c.render === "function") {
        return (
          <div className="popup-body">
            {c.render()}
          </div>
        );
      }

      return (
        <div className="popup-body">
          {c.title && <h3 style={{margin:"0 0 6px"}}>{c.title}</h3>}
          <p className="fill" style={{whiteSpace:"pre-line"}}>{c.text || "No content."}</p>
        </div>
      );
    }

    function FPGAHome({ rows=7, cols=7, tiles, links }) {
      const [hoverId, setHoverId] = useState(null);

      // popup state
      const [active, setActive] = useState(null);
      const [popupRect, setPopupRect] = useState(null);
      const wrapRef = useRef(null);
      const svgRef  = useRef(null);

      // click highlight state
      const [clickedId, setClickedId]   = useState(null);
      const [flashSpec, setFlashSpec]   = useState(null); // {mode, seq, perEdge, grads, tileHaloById}
      const clickTimerRef = useRef(null);
      const clickSeqRef   = useRef(0);
      // timer for end-glow auto-clear
      const endGlowTimerRef = useRef(null);

      // close on ESC
      useEffect(()=>{
        const onKey = (e)=>{ if (e.key === "Escape") { clearClickFlash(); setActive(null); } };
        window.addEventListener("keydown", onKey);
        return ()=>window.removeEventListener("keydown", onKey);
      }, []);
      // unmount cleanup (clear timers)
      useEffect(()=>()=> {
        clearClickFlash();
        if (endGlowTimerRef.current) clearTimeout(endGlowTimerRef.current);
      }, []);

      // bitstream-style column sweep (one-time)
      const [activeCol, setActiveCol] = useState(-1);
      const sweepOnce = useRef(false);
      useEffect(() => {
        if (sweepOnce.current) return;
        sweepOnce.current = true;
        let col=-1;
        const step=45;
        const t=setInterval(()=>{ col++; setActiveCol(col); if(col>=cols+2) clearInterval(t); }, step);
        if (window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches){
          setActiveCol(cols+2); clearInterval(t);
        }
        return ()=>clearInterval(t);
      },[cols]);

      /* --- Wave clock for initial trace draw --- */
      const waveStartRef = useRef(null);
      const [waveNow, setWaveNow] = useState(0);
      useEffect(() => {
        const reduce = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
        if (reduce) { setWaveNow(Number.POSITIVE_INFINITY); return; }
        let raf;
        const startAt = performance.now() + WAVE_START_DELAY_MS;
        waveStartRef.current = startAt;
        const tick = (t) => { setWaveNow(t); raf = requestAnimationFrame(tick); };
        raf = requestAnimationFrame(tick);
        return () => cancelAnimationFrame(raf);
      }, []);

      // geometry
      const w = cols*size + (cols-1)*gap;
      const h = rows*size + (rows-1)*gap;

      const cellRect = (r,c) => ({ x:c*(size+gap), y:r*(size+gap), w:size, h:size });
      const tileRectFor = (t) => {
        const spanR = t?.spanR ?? 1, spanC = t?.spanC ?? 1;
        const x = t.c*(size+gap), y = t.r*(size+gap);
        const w = spanC*size + (spanC-1)*gap, h = spanR*size + (spanR-1)*gap;
        return { x, y, w, h };
      };
      const edgePointFor = (t, side) => {
        const {x,y,w,h} = tileRectFor(t);
        if (side==="L") return [x, y+h/2];
        if (side==="R") return [x+w, y+h/2];
        if (side==="T") return [x+w/2, y];
        return [x+w/2, y+h];
      };
      const vChanX = (k) => (k>=1 && k<=cols-1) ? (k*(size+gap) - gap/2) : null;
      const hChanY = (k) => (k>=1 && k<=rows-1) ? (k*(size+gap) - gap/2) : null;

      const tileById = useMemo(()=>{ const m=new Map(); tiles.forEach(t=>m.set(t.id,t)); return m; },[tiles]);

      const KIND_COLOR = {
        CLB:"var(--tile)", DSP:"var(--dsp)", BRAM:"var(--bram)", IO:"var(--io)",
        PCIE:"var(--pcie)", PLL:"var(--pll)", rsch:"var(--rsch)", PROJ:"var(--proj)"
      };
      const fillFor = (t) => t ? (KIND_COLOR[t.kind] || "var(--tile)") : "#e5e7eb";

      function compressPath(pts){
        const dedup = [pts[0]];
        for (let i=1;i<pts.length;i++){
          const [ax,ay]=dedup[dedup.length-1], [bx,by]=pts[i];
          if (Math.abs(ax-bx)>0.5 || Math.abs(ay-by)>0.5) dedup.push([bx,by]);
        }
        const out = [dedup[0]];
        for (let i=1;i<dedup.length-1;i++){
          const [x0,y0]=out[out.length-1], [x1,y1]=dedup[i], [x2,y2]=dedup[i+1];
          const collinear = (Math.abs(x0-x1)<0.5 && Math.abs(x1-x2)<0.5) ||
                            (Math.abs(y0-y1)<0.5 && Math.abs(y1-y2)<0.5);
          if (!collinear) out.push([x1,y1]);
        }
        out.push(dedup[dedup.length-1]);
        return out;
      }

      function routeBetween(src, dst){
        const srcCenterC = src.c + (src.spanC ?? 1)/2;
        const srcCenterR = src.r + (src.spanR ?? 1)/2;
        const dstCenterC = dst.c + (dst.spanC ?? 1)/2;
        const dstCenterR = dst.r + (dst.spanR ?? 1)/2;

        let exitSide, enterSide;
        if (dstCenterC > srcCenterC) { exitSide="R"; enterSide="L"; }
        else if (dstCenterC < srcCenterC) { exitSide="L"; enterSide="R"; }
        else if (dstCenterR > srcCenterR) { exitSide="B"; enterSide="T"; }
        else { exitSide="T"; enterSide="B"; }

        const [sx,sy] = edgePointFor(src, exitSide);
        const [dx,dy] = edgePointFor(dst, enterSide);

        if (Math.round(srcCenterR) === Math.round(dstCenterR)) {
          const rowIdx = Math.max(1, Math.min(rows-1, Math.round(srcCenterR)));
          const yh = hChanY(rowIdx);
          return compressPath([[sx,sy],[sx,yh],[dx,yh],[dx,dy]]);
        }
        if (Math.round(srcCenterC) === Math.round(dstCenterC)) {
          const colIdx = Math.max(1, Math.min(cols-1, Math.round(srcCenterC)));
          const xv = vChanX(colIdx);
          return compressPath([[sx,sy],[xv,sy],[xv,dy],[dx,dy]]);
        }

        const srcRightCol = src.c + (src.spanC ?? 1);
        const srcBottomRow = src.r + (src.spanR ?? 1);
        const dstRightCol = dst.c + (dst.spanC ?? 1);
        const dstBottomRow = dst.r + (dst.spanR ?? 1);

        const vStart = exitSide==="R" ? vChanX(srcRightCol) : exitSide==="L" ? vChanX(src.c) : null;
        const hStart = exitSide==="B" ? hChanY(srcBottomRow) : exitSide==="T" ? hChanY(src.r) : null;

        const vEnd   = enterSide==="L" ? vChanX(dst.c) : enterSide==="R" ? vChanX(dstRightCol) : null;
        const hEnd   = enterSide==="T" ? hChanY(dst.r) : enterSide==="B" ? hChanY(dstBottomRow) : null;

        const xvStart = vStart ?? vChanX(Math.max(1, Math.min(cols-1, Math.round(srcCenterC))));
        const xvEnd   = vEnd   ?? vChanX(Math.max(1, Math.min(cols-1, Math.round(dstCenterC))));
        const yhStart = hStart ?? hChanY(Math.max(1, Math.min(rows-1, Math.round(srcCenterR))));
        const yhEnd   = hEnd   ?? hChanY(Math.max(1, Math.min(rows-1, Math.round(dstCenterR))));

        const goVerticalFirst = Math.abs(dstCenterC - srcCenterC) >= Math.abs(dstCenterR - srcCenterR);
        return goVerticalFirst
          ? compressPath([[sx,sy],[xvStart,sy],[xvStart,yhEnd],[xvEnd,yhEnd],[xvEnd,dy],[dx,dy]])
          : compressPath([[sx,sy],[sx,yhStart],[xvEnd,yhStart],[xvEnd,dy],[dx,dy]]);
      }

      /* --- Origin & ring map for wave --- */
      const originTile = useMemo(() => tiles.find(t => t.id === WAVE_FROM_ID) ?? tiles[0], [tiles]);
      const originCR   = useMemo(() => [originTile.c + (originTile.spanC ?? 1)/2,
                                        originTile.r + (originTile.spanR ?? 1)/2], [originTile]);

      const ringById = useMemo(() => {
        const m = new Map();
        tiles.forEach(t => m.set(t.id, ringFromTo([t.c + (t.spanC ?? 1)/2, t.r + (t.spanR ?? 1)/2], originCR)));
        return m;
      }, [tiles, originCR]);

      const wirePaths = useMemo(()=>{
        const out=[];
        const startAt = waveStartRef.current ?? 0;

        for (const L of links){
          const s = tileById.get(L.for), d = tileById.get(L.to);
          if (!s || !d) continue;

          const pts = routeBetween(s,d);
          const len = pathLen(pts);

          const ring = Math.min(ringById.get(s.id) ?? 0, ringById.get(d.id) ?? 0);
          const localMs = waveNow - startAt - ring*WAVE_RING_STEP_MS;
          const prog = (Number.isFinite(localMs) ? Math.max(0, Math.min(1, localMs / WAVE_DRAW_MS)) : 1);

          const readyCol = (d.c <= activeCol);
          out.push({ for:L.for, to:L.to, pts, len, ring, prog, readyCol });
        }
        return out;
      }, [links, tileById, ringById, activeCol, waveNow]);

      const isRelated = (wire, tid) => wire.for===tid || wire.to===tid;

      /* ===== Build per-click (or all) flash spec ===== */
      const ALL_ID = "__ALL__";
      const rand = (a,b)=>a + Math.random()*(b-a);
      const randomVivid = ()=>`hsl(${Math.floor(rand(0,360))}deg, 80%, 62%)`;

      function buildFlashSpecFor(tileId){
        const perEdge = new Map();
        const grads = [];
        const tileHaloById = new Map();
        const seq = ++clickSeqRef.current;

        const byKey = new Map();
        wirePaths.forEach((w)=>{
          const key = `${w.for}|${w.to}`;
          byKey.set(key, {start:w.pts[0], end:w.pts[w.pts.length-1]});
        });

        // Wires
        wirePaths.forEach((w, idx)=>{
          const include = (tileId === ALL_ID) || (w.for === tileId || w.to === tileId);
          if (!include) return;
          const key = `${w.for}|${w.to}`;

          if (FLASH_MODE === "random") {
            perEdge.set(key, { type:"color", color: randomVivid() });
          } else if (FLASH_MODE === "gradient") {
            const s = byKey.get(key).start, e = byKey.get(key).end;
            const id = `grad-${seq}-${idx}`;
            const c1 = randomVivid(), c2 = randomVivid();
            grads.push({ id, x1:s[0], y1:s[1], x2:e[0], y2:e[1], c1, c2 });
            perEdge.set(key, { type:"gradient", id });
          } else {
            perEdge.set(key, { type:"color", color: "var(--flash)" });
          }
        });

        // Tile halos
        const targetTiles = (tileId === ALL_ID) ? tiles : [tileById.get(tileId)].filter(Boolean);
        for (const t of targetTiles) {
          if (FLASH_MODE === "gradient") {
            const {x,y,w,h} = tileRectFor(t);
            const id = `tilegrad-${seq}-${t.id}`;
            const c1 = randomVivid(), c2 = randomVivid();
            grads.push({ id, x1:x, y1:y, x2:x+w, y2:y+h, c1, c2 });
            tileHaloById.set(t.id, { type:"gradient", id });
          } else if (FLASH_MODE === "random") {
            tileHaloById.set(t.id, { type:"color", color: randomVivid() });
          } else {
            tileHaloById.set(t.id, { type:"color", color: "var(--flash)" });
          }
        }

        return { mode: FLASH_MODE, seq, perEdge, grads, tileHaloById };
      }

      function clearClickFlash(){
        if (clickTimerRef.current) { clearTimeout(clickTimerRef.current); clickTimerRef.current = null; }
        setClickedId(null);
        setFlashSpec(null);
      }

      function handleTileClick(tile, e){
        e.preventDefault();
        clearClickFlash(); setActive(null); setHoverId(null);
        setClickedId(tile.id);
        setFlashSpec(buildFlashSpecFor(tile.id));
        clickTimerRef.current = setTimeout(()=>{ openPopup(tile); clearClickFlash(); }, FLASH_MS);
      }
      const isHovering = (id) => (clickedId ? false : (hoverId === id));

      /* ===== One-time glow burst after all wires finish drawing (auto-clears) ===== */
      const endGlowOnce = useRef(false);
      useEffect(() => {
        if (endGlowOnce.current) return;
        const reduce = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
        if (reduce) return;

        const allDone = wirePaths.length > 0 && wirePaths.every(w => w.prog >= 1 && w.readyCol);
        if (!allDone) return;

        // If user is interacting, skip the end glow
        if (clickedId || active) return;

        endGlowOnce.current = true;
        setClickedId(ALL_ID);
        setFlashSpec(buildFlashSpecFor(ALL_ID));

        if (endGlowTimerRef.current) clearTimeout(endGlowTimerRef.current);
        endGlowTimerRef.current = setTimeout(() => {
          clearClickFlash();                 // restore neutral wire color
          endGlowTimerRef.current = null;
        }, END_GLOW_MS);
      }, [wirePaths, clickedId, active]);

      /* --- BUSY/DONE logic: BUSY is ON during wave draw, any flash, or popup --- */
      const waveInProgress = useMemo(() => {
        const reduce = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
        if (reduce) return false;                                     // skip on reduced motion
        if (!waveStartRef.current) return true;                        // just mounted, treat as busy
        if (wirePaths.length === 0) return true;                       // before routes are computed
        return wirePaths.some(w => w.prog < 1);                        // any wire still drawing
      }, [wirePaths]);

      const busy = Boolean(clickedId || active || waveInProgress);

      /* Popup helpers */
      const openPopup = (tile, evt) => {
        evt?.preventDefault?.();
        setActive(tile);

        const {x,y,w:tw,h:th} = tileRectFor(tile);
        const wrapBox = wrapRef.current.getBoundingClientRect();
        const svgBox  = svgRef.current.getBoundingClientRect();

        const overrides = tile.popup || tile.content || {};
        const mode   = overrides.coverMode  ?? COVER_MODE;
        const ratioW = overrides.coverRatio ?? COVER_RATIO;
        const ratioH = overrides.heightRatio ?? HEIGHT_RATIO;
        const pxW    = overrides.width;
        const pxH    = overrides.height;
        const offX  = pxOrPct(overrides.offsetX,  svgBox.width);
        const offY  = pxOrPct(overrides.offsetY,  svgBox.height);
        const sOffX = pxOrPct(overrides.startOffsetX ?? overrides.offsetX, svgBox.width);
        const sOffY = pxOrPct(overrides.startOffsetY ?? overrides.offsetY, svgBox.height);

        const leftStart = (svgBox.left - wrapBox.left) + x + sOffX + PAD;
        const topStart  = (svgBox.top  - wrapBox.top)  + y + sOffY + PAD;

        let target = {};
        if (Number.isFinite(pxW) && Number.isFinite(pxH)) {
          const tW = pxW, tH = pxH;
          target = {
            left:(svgBox.left - wrapBox.left) + (svgBox.width - tW)/2,
            top: (svgBox.top  - wrapBox.top)  + (svgBox.height- tH)/2,
            width:tW, height:tH
          };
        } else if (mode === "full") {
          target = {
            left:   (svgBox.left - wrapBox.left),
            top:    (svgBox.top  - wrapBox.top),
            width:  svgBox.width,
            height: svgBox.height
          };
        } else {
          const rW = Math.max(0.2, ratioW);
          const rH = Math.max(0.2, ratioH);
          const tW = svgBox.width  * rW;
          const tH = svgBox.height * rH;

          const anchorTop = !!overrides.anchorTop;
          const topRef = (svgBox.top - wrapBox.top) + (svgBox.height - (svgBox.height * rW))/2;

          target = {
            left:  (svgBox.left - wrapBox.left) + (svgBox.width  - tW)/2,
            top:   anchorTop ? topRef : (svgBox.top - wrapBox.top) + (svgBox.height - tH)/2,
            width: tW, height:tH
          };
        }

        target.left += offX;
        target.top  += offY;

        setPopupRect({ left: leftStart, top: topStart, width: tw, height: th, target });
        requestAnimationFrame(()=> {
          setPopupRect(prev => prev ? ({ ...prev, left: prev.target.left, top: prev.target.top, width: prev.target.width, height: prev.target.height }) : prev);
        });
      };
      const closePopup = () => setActive(null);

      return (
        <div className="wrap" ref={wrapRef} style={{position:"relative"}}>
          {/* Header row with LEDs on the right */}
          <div className="header-row">
            <h1 style={{margin:0,fontSize:32,color:"#cbd5e1"}}>Alexander DeFalco</h1>
            <StatusLEDs busy={busy} />
          </div>

          <p className="sub">
            Welcome to my single-page Portfolio Website!
          </p>

          <svg
            ref={svgRef}
            viewBox={`0 0 ${w + PAD*2} ${h + PAD*2}`}
            style={{width:"100%",height:"auto",boxShadow:"0 12px 36px rgba(0,0,0,.35)",borderRadius:14}}
            role="grid" aria-label="FPGA-style navigation"
          >
            <defs>
              <filter id="softGlow" x="-60%" y="-60%" width="220%" height="220%">
                <feGaussianBlur in="SourceGraphic" stdDeviation="5" result="blur"/>
                <feMerge><feMergeNode in="blur"/></feMerge>
              </filter>

              <filter id="tileShadow" x="-40%" y="-40%" width="180%" height="180%">
                <feDropShadow dx="0" dy="2" stdDeviation="1.6" floodColor="#000" floodOpacity="0.28"/>
                <feDropShadow dx="0" dy="8" stdDeviation="6"   floodColor="#000" floodOpacity="0.18"/>
              </filter>

              <linearGradient id="tileShade" x1="0" y1="0" x2="0" y2="1">
                <stop offset="0%"  stopColor="#FFFFFF" stopOpacity="0.16"/>
                <stop offset="42%" stopColor="#FFFFFF" stopOpacity="0.04"/>
                <stop offset="58%" stopColor="#000000" stopOpacity="0.04"/>
                <stop offset="100%" stopColor="#000000" stopOpacity="0.12"/>
              </linearGradient>

              {flashSpec?.grads?.map(g=>(
                <linearGradient key={g.id} id={g.id} gradientUnits="userSpaceOnUse"
                  x1={g.x1 + PAD} y1={g.y1 + PAD} x2={g.x2 + PAD} y2={g.y2 + PAD}>
                  <stop offset="0%"   stopColor={g.c1}/>
                  <stop offset="100%" stopColor={g.c2}/>
                </linearGradient>
              ))}
            </defs>

            <g transform={`translate(${PAD},${PAD})`}>
              {/* WIRES */}
              <g>
                {wirePaths.map((wPath,i)=>{
                  const flashingAll = clickedId === ALL_ID;
                  const flashing = flashingAll || (clickedId && (wPath.for === clickedId || wPath.to === clickedId));
                  const hotHover = !clickedId && (hoverId && isRelated(wPath, hoverId));

                  let flashStroke = "var(--flash)";
                  if (flashing && flashSpec) {
                    const spec = flashSpec.perEdge.get(`${wPath.for}|${wPath.to}`);
                    if (spec?.type === "gradient") flashStroke = `url(#${spec.id})`;
                    else if (spec?.type === "color") flashStroke = spec.color;
                  }

                  const stroke = flashing ? flashStroke : (hotHover ? "var(--wire-hot)" : "var(--wire)");
                  const width  = flashing ? 3 : (hotHover ? 3 : 2);

                  const baseMin = 0.12;
                  const baseMax = hotHover ? 0.95 : 0.55;
                  const fade    = flashing ? 1 : (baseMin + (baseMax - baseMin) * easeInOut(wPath.prog));
                  const opacity = flashing ? 0.98 : (wPath.readyCol ? fade : baseMin);

                  const dashArray  = flashing ? "none" : wPath.len;
                  const dashOffset = flashing ? 0      : (1 - wPath.prog) * wPath.len;

                  return (
                    <g key={i}>
                      {flashing && (
                        <polyline
                          className="wireHalo animate"
                          points={wPath.pts.map(([x,y])=>`${x},${y}`).join(" ")}
                          fill="none"
                          stroke={flashStroke}
                          strokeWidth={15}
                          strokeLinecap="round"
                          strokeLinejoin="round"
                        />
                      )}
                      <polyline
                        className={`wire ${flashing ? "wire--flash" : ""}`}
                        points={wPath.pts.map(([x,y])=>`${x},${y}`).join(" ")}
                        fill="none"
                        stroke={stroke}
                        strokeWidth={width}
                        opacity={opacity}
                        strokeLinejoin="round" strokeLinecap="butt"
                        style={{ strokeDasharray: dashArray, strokeDashoffset: dashOffset }}
                      />
                    </g>
                  );
                })}
              </g>

              {/* BACKGROUND GRID CELLS */}
              {Array.from({length: rows}).map((_,r)=>
                Array.from({length: cols}).map((__,c)=>{
                  const {x,y,w:ww,h:hh} = cellRect(r,c);
                  return (
                    <rect key={`bg-${r}-${c}`} x={x} y={y} width={ww} height={hh} rx={6}
                          fill="#e5e7eb" opacity="0.12" stroke="var(--stroke)" strokeWidth="1"/>
                  );
                })
              )}

              {/* TILES */}
              {tiles.map((t)=>{
                const {x,y,w:tw,h:th} = tileRectFor(t);
                const isHot = isHovering(t.id);
                const colActive = t.c <= activeCol;
                const baseOpacity = colActive ? 1 : 0.15;
                const tileFlashing = (clickedId === t.id) || (clickedId === ALL_ID);

                let haloStroke = null;
                const haloSpec = flashSpec?.tileHaloById?.get(t.id);
                if (tileFlashing && haloSpec) {
                  haloStroke = (haloSpec.type === "gradient")
                    ? `url(#${haloSpec.id})`
                    : (haloSpec.color || "var(--flash)");
                }

                return (
                  <a key={t.id} href={t.href||"#"} tabIndex={0} aria-label={t.label}
                    onMouseEnter={()=>!clickedId && setHoverId(t.id)} onMouseLeave={()=>setHoverId(null)}
                    onFocus={()=>!clickedId && setHoverId(t.id)} onBlur={()=>setHoverId(null)}
                    onClick={(e)=>handleTileClick(t, e)} style={{outline:"none", cursor:"pointer"}}>

                    {tileFlashing && haloStroke && (
                      <rect className="tileHalo animate"
                        x={x} y={y} width={tw} height={th} rx={6}
                        fill="none" stroke={haloStroke} strokeWidth="16" />
                    )}

                    <rect x={x} y={y} width={tw} height={th} rx={6}
                          fill={fillFor(t)}
                          opacity={isHot ? 1 : baseOpacity*0.95}
                          stroke={isHot ? "var(--hot)" : "var(--stroke)"} strokeWidth={isHot?2:1}
                          filter="url(#tileShadow)"
                          style={{transition:"opacity .18s ease, stroke .18s ease, transform .18s ease",
                                  transform: isHot ? "translateY(-1px)" : "none"}} />

                    <rect x={x} y={y} width={tw} height={th} rx={6}
                          fill="url(#tileShade)" pointerEvents="none" />

                    <Label t={t} x={x} y={y} tw={tw} th={th} fontSize={fontSize} opacity={colActive?0.9:0} />
                  </a>
                );
              })}
            </g>
          </svg>

          {/* POPUP */}
          <div className={`overlay ${active ? "open" : ""}`} aria-hidden={!active} onClick={(e)=>{ if(e.target === e.currentTarget) closePopup(); }}>
            {active && popupRect && (
              <div className="popup" role="dialog" aria-modal="true"
                   style={{left: popupRect.left, top: popupRect.top, width: popupRect.width, height: popupRect.height}}>
                <div className="popup-content">
                  <div className="popup-header">
                    <div>
                      {active.label}
                      <span className="tag">{active.kind ?? "Tile"}</span>
                    </div>
                    <button className="close-btn" onClick={closePopup} autoFocus aria-label="Close">✕ Close</button>
                  </div>
                  <PopupBody tile={active}/>
                </div>
              </div>
            )}
          </div>

          {hoverId && !clickedId && (() => {
            const t = tiles.find(x=>x.id===hoverId);
            return <div className="tooltip">{t?.label}</div>;
          })()}
        </div>
      );
    }

    /* ---------- Sample data with per-tile content ---------- */
const tiles = [
  { id:"About Me", r:2, c:2, label:"About\nMe", kind:"IO",
    content: {
      type: "html",
      html: `
    <h3 style="margin:0 0 8px">Hi! I’m Alex, a Computer Engineering Senior from the University of Central Florida.</h3>

    <p>I'm extremely passionate about computer architecture, full-flow VLSI Design, hardware security, and hardware acceleration. \
        I am currently in the last year of my undergrad, and am on track to complete my Master's Degree in Computer Engineering from \
        UCF by Spring 2027.</p>

    <h4 style="margin:14px 0 6px">What got me into Computer Engineering?</h4>
    <p>
      Growing up, my dad was a printer. He would always find his hands on new tools and technologies,
      eventually ending up with a CO<sub>2</sub> laser engraver. I always found myself mesmerized by how these
      machines would physically begin moving after a few clicks and keystrokes on a computer. This curiosity began
      when I was only five years old, and from then on I was hooked, leading me 20+ years later to be where I am today.
    </p>

    <h4 style="margin:14px 0 6px">Early PC tinkering</h4>
    <p>
      I built my first computer when I was 14, fitted with an AMD A4-6300 and a NVIDIA GTX 660 (which is still
      running in a home office PC). I remember struggling to run Far Cry 3, and eventually my dad helped me upgrade
      the CPU to an Intel i5-4690K. This was when I first learned about bottlenecks and per-generation uplifts in
      computing technology. From here, I was always curious to study new hardware releases—learning not just which CPU
      or GPU was better, but also why. I was curious to learn what, architecturally, made a piece of silicon better
      than what came out only the previous year. I'm proud to have chased this curiosity to date, excited to find my
      way into the workforce for computer architecture and digital design.
    </p>

    <h4 style="margin:14px 0 6px">Today</h4>
    <p>
        While at UCF, I like to stay involved within the ECE community. <br>
        I'm an active member of my university's IEEE, ACM, and KnightHacks chapters. \
        I am also a member of the IEEE HKN (Eta Kappa Nu) Honor Society, and a peer mentor for the STRONG-AI scholarship program. \
        More than anything else, I absolutely love to share my passion with those around me, nurturing growth in the domains of Electrical and Computer engineering as best as I possibly can.
    </p>

    <h4 style="margin:14px 0 6px">Goals</h4
    <p>
      My overall goal with my education and career is to contribute to computing hardware that impacts
      people in their day-to-day lives.
    </p>

    <h4 style="margin:14px 0 6px">Things I enjoy</h4>
    <ul style="margin:0 0 0 18px; padding:0;">
      <li>Turning RTL + CAD ideas into visuals</li>
      <li>eFPGA fabrics, SECDED, gem5</li>
    </ul>
  `
    },
    popup:  { coverMode:"ratio", coverRatio:1, heightRatio:1.425, anchorTop:true, startOffsetY:0, offsetY:-80 }
  },

  { id:"website", r:2, c:4, label:"About\nThis\nWebsite", kind:"CLB",
    content: {
      type:"html",
      html: `
        <h3 style="margin:0 0 8px">About This Website</h3>
        <p>This site is a single-file React app that visualizes an FPGA-style fabric. Tiles behave like CLBs/IO/DSP/BRAM, and routes are constrained to inter-tile channels.</p>

        <h4 style="margin:14px 0 6px">Interaction model</h4>
        <ul style="margin:0 0 8px 18px">
          <li>Hover: subtle highlight on wires and tiles</li>
          <li>Click: flash connected routes, then open a detail card</li>
          <li>Wave boot: traces “draw” outward from an origin tile</li>
        </ul>

        <h4 style="margin:14px 0 6px">Tech stack</h4>
        <ul style="margin:0 0 8px 18px">
          <li>React 18 (CDN) + inline Babel</li>
          <li>Pure SVG for layout, no external canvas libs</li>
          <li>Accessible markup (ARIA labels, keyboard focus)</li>
        </ul>

        <h4 style="margin:14px 0 6px">Future ideas</h4>
        <ul style="margin:0 0 0 18px">
          <li>Deep links to open a tile via <code>#hash</code></li>
          <li>Row/column legends and IO bank labels</li>
          <li>Board frame, via field, and silkscreen details</li>
        </ul>
      `
    },
    popup:  { coverMode:"ratio", coverRatio:1, heightRatio:1.425, anchorTop:true, startOffsetY:0, offsetY:-80 }
  },

  { id:"resume", r:0, c:0, label:"My\nResume", kind:"IO", spanR:2, spanC:1,
    content:{ type:"pdf", title:"Resume (PDF)", src:"resume.pdf" },
    popup:  { coverMode:"ratio", coverRatio:1, heightRatio:1.425, anchorTop:true, startOffsetY:0, offsetY:-80 }
  },

  { id:"research", r:3, c:0, label:"Research\nExperience", kind:"rsch", spanR:2, spanC:1,
    content: {
      type:"html",
      html: `
        <h3 style="margin:0 0 8px">Research Experience</h3>
        <p>I explore programmable fabrics, on-chip networks, and reliability/security interactions across the memory hierarchy.</p>

        <h4 style="margin:14px 0 6px">Areas</h4>
        <ul style="margin:0 0 8px 18px">
          <li>eFPGA fabrics and SoC integration</li>
          <li>Cache coherence &amp; LLC behavior</li>
          <li>Reliability (SECDED/ECC) and fault models</li>
          <li>Hardware security &amp; side channels</li>
        </ul>

        <h4 style="margin:14px 0 6px">Selected efforts</h4>
        <ul style="margin:0 0 0 18px">
          <li>Bitstream-style configuration sweeps for eFPGAs</li>
          <li>Coherence experiments in gem5</li>
          <li>Syndrome visualization for SECDED pipelines</li>
        </ul>
      `
    },
    popup:  { coverMode:"ratio", coverRatio:1, heightRatio:1.425, anchorTop:true, startOffsetY:0, offsetY:-80 }
  },

  { id:"eFPGA", r:4, c:3, label:"eFPGA", kind:"rsch",
    content: {
      type:"html",
      html: `
        <h3 style="margin:0 0 8px">Embedded FPGA (eFPGA)</h3>
        <p>Tile-based fabric embedded within an SoC to accelerate domain-specific kernels and enable post-silicon flexibility.</p>

        <h4 style="margin:14px 0 6px">Fabric &amp; routing</h4>
        <p>Parameterized switch boxes with Manhattan routing over inter-tile channels. Configuration loaded via a sweep that mirrors bitstream behavior.</p>

        <h4 style="margin:14px 0 6px">Highlights</h4>
        <ul style="margin:0 0 0 18px">
          <li>Programmable datapaths &amp; simple DSP operator tiles</li>
          <li>ISR-friendly partial reconfiguration model (concept)</li>
          <li>Visualization synced to route computation</li>
        </ul>
      `
    },
    popup:  { coverMode:"ratio", coverRatio:1, heightRatio:1.425, anchorTop:true, startOffsetY:0, offsetY:-80 }
  },

  { id:"ZKPs", r:4, c:1, label:"ZKPs", kind:"rsch",
    content: {
      type:"html",
      html: `
        <h3 style="margin:0 0 8px">Zero-Knowledge Proofs (Exploration)</h3>
        <p>Investigating hardware-accelerated primitives relevant to ZKP pipelines and succinct proofs.</p>

        <h4 style="margin:14px 0 6px">Focus</h4>
        <ul style="margin:0 0 8px 18px">
          <li>Efficient finite-field arithmetic on reconfigurable fabric</li>
          <li>Memory layout considerations for MSM/FFT kernels</li>
          <li>Interplay between throughput, area, and programmability</li>
        </ul>

        <h4 style="margin:14px 0 6px">Next steps</h4>
        <ul style="margin:0 0 0 18px">
          <li>Prototype MSM accelerator tile</li>
          <li>Co-design with host runtime for batching</li>
        </ul>
      `
    },
    popup:  { coverMode:"ratio", coverRatio:1, heightRatio:1.425, anchorTop:true, startOffsetY:0, offsetY:-80 }
  },

  { id:"intern", r:3, c:4, label:"Internship\nExperience", kind:"DSP", spanR:2, spanC:1,
    content: {
      type:"html",
      html: `
        <h3 style="margin:0 0 8px">Internship Experience</h3>
        <p>Hands-on exposure to FPGA prototyping, verification, and performance-focused digital design.</p>

        <h4 style="margin:14px 0 6px">Highlights</h4>
        <ul style="margin:0 0 8px 18px">
          <li>Hardware prototyping and bring-up on FPGA</li>
          <li>Timing closure, floorplanning, and constraint tuning</li>
          <li>Verification (SystemVerilog/UVM) and testbench authoring</li>
          <li>Documentation &amp; design reviews</li>
        </ul>

        <h4 style="margin:14px 0 6px">Impact</h4>
        <p>Improved iteration speed by tightening build pipelines and refining debug visibility through strategic instrumentation.</p>
      `
    },
    popup:  { coverMode:"ratio", coverRatio:1, heightRatio:1.425, anchorTop:true, startOffsetY:0, offsetY:-80 }
  },

  { id:"NG", r:2, c:3, label:"Northrop\nGrumman\nSummer\n2025", kind:"DSP",
    content: {
      type:"html",
      html: `
        <h3 style="margin:0 0 8px">Northrop Grumman — Summer 2025</h3>
        <p>Upcoming summer internship focused on digital design and verification.</p>

        <h4 style="margin:14px 0 6px">Focus areas</h4>
        <ul style="margin:0 0 8px 18px">
          <li>RTL development and verification workflows</li>
          <li>FPGA prototyping and lab validation</li>
          <li>Performance analysis and timing closure</li>
        </ul>

        <h4 style="margin:14px 0 6px">Goals</h4>
        <ul style="margin:0 0 0 18px">
          <li>Deliver measurable improvements to subsystem throughput or resource usage</li>
          <li>Contribute tests and documentation for long-term maintainability</li>
        </ul>
      `
    },
    popup:  { coverMode:"ratio", coverRatio:1, heightRatio:1.425, anchorTop:true, startOffsetY:0, offsetY:-80 }
  },

  { id:"Projects", r:0, c:4, label:"My\nProjects", kind:"PROJ", spanR:2, spanC:1,
    content: {
      type:"html",
      html: `
        <h3 style="margin:0 0 8px">Projects (Gateway)</h3>
        <p>Click a project tile in the grid to open details. This card acts as a hub with quick notes and links.</p>

        <h4 style="margin:14px 0 6px">Pinned</h4>
        <ul style="margin:0 0 8px 18px">
          <li>SECDED (ECC on cache lines)</li>
          <li>eFPGA fabric visualization</li>
          <li>Coherence &amp; LLC experiments in gem5</li>
        </ul>

        <h4 style="margin:14px 0 6px">Tips</h4>
        <ul style="margin:0 0 0 18px">
          <li>Watch the wire flash when you click a project—those are the relevant connections.</li>
          <li>Use ESC to close any card quickly.</li>
        </ul>
      `
    },
    popup:  { coverMode:"ratio", coverRatio:1, heightRatio:1.425, anchorTop:true, startOffsetY:0, offsetY:-80 }
  },

  { id:"p1", r:0, c:1, label:"SECDED\nModule\nDesign", kind:"PROJ",
    content: {
      type:"html",
      html: `
        <h3 style="margin:0 0 8px">Single Error Correcting, Double Error Detecting Module Design</h3>

        <a href="https://github.com/ajdef/SECDED-Hamming84/blob/main/README.md" 
        style="color:#34d399; text-decoration:none;">
        Check out the code on my github!
        </a>
        
        <p>This personal project was my first endeavor into digital design after having taken my introduction to Digital Logic course (Digital Systems).
            
            It includes verilog modules  and testbench designs for an Extended Hamming(7,4) implementation, sometimes referred to as Hamming(8,4).
            </p>

        <h4 style="margin:14px 0 6px">What is Hamming Code?</h4>
        <p>Hamming code is a form of error correcting code (ECC) that is able to detect and correct single bit errors within the transmission \
            of data through the addition of redundant/parity bits. An additional parity bit is able to be added to a hamming code implementation \
            in order to add double bit error detection (not correction).</p>

        <h4 style="margin:14px 0 6px"> Features:</h4>
        <ul style="margin:0 0 8px 18px">
          <li>Encoder takes in 4 bit data input, encoding to 8 bits enabling SECDED behavior</li>
          <li>Decoder takes in 8 bit encoded data and resolves the 4 data bits it represents, correcting single bit errors and detecting double bit errors</li>
          <li>Testbenches cover all cases for data encoding, and all typical cases for data decoding</li>
          <li>Design validated on Artix-7 FPGA through dip-switch inputs and LED outputs</li>
        </ul>

        <h4 style="margin:14px 0 6px">Things I want to improve upon:</h4>
        <ul style="margin:0 0 0 18px">
          <li>Utilize UVM to expand functional coverage of decoder module</li>
          <li>Modularize the design to work on larger input vectors (eg. Hamming(15,11))</li>
          <li>Automate FPGA Validation through the usage of a logic analyzer</li>
          <li>Upload images showcasing existing FPGA validation sequences</li>
        </ul>

        
      `
    },
    popup:  { coverMode:"ratio", coverRatio:1, heightRatio:1.425, anchorTop:true, startOffsetY:0, offsetY:-80 }
  },

  { id:"p2", r:0, c:3, label:"SCALER\nRISC-V\nExtension\n(WIP)", kind:"PROJ",
    content: {
      type:"html",
      html: `
      <h3 style="margin:0 0 8px">SCALER: Side-Channel Leakage Reduction Extension for RISC-V (Senior Design Capstone, In Progress)</h3>

        <a href="" 
        style="color:#34d399; text-decoration:none;">
        UCF Website link for our capstone project! (not yet available)
        </a>

        <p>This ongoing group project is my (our) undergraduate capstone, in which we take an existing RISC-V core design (Ibex) that utilizes 
            the RV32I extension and implement both commonly implemented ISA extensions as well as custom ones to mitigate side channel attacks 
            through modern research topics such as noise injection and boolean masking. This project has been generously sponsored by Northrop Grumman.
        </p>

        <h4 style="margin:14px 0 6px">What is the purpose of this project?</h4>

        <p>This project proves to be rather atypical to what a capstone at UCF normally encompasses. Through this project, we aim to develop our personal 
            skillsets within the full ASIC design flow, spanning from the initial design phases all the way up to tape-out.
            UCF's partnership with Cadence has generously provided us with an immense number of training courses alongside their EDA toolchains, ensuring 
            that we are able to learn actual industry tools the way they are intended to be used.
        </p>

        <h4 style="margin:14px 0 6px">Who's on the team?</h4>
        <ul style="margin:0 0 8px 18px">
        <li><a href="https://www.linkedin.com/in/ajdef/" style="color:#34d399; text-decoration:none;">Alexander DeFalco</a> - Computer Engineering</li>
        <li><a href="https://www.linkedin.com/in/joshuavjoseph/" style="color:#34d399; text-decoration:none;">Joshua Joseph</a> - Computer Engineering</li>
        <li><a href="https://www.linkedin.com/in/danielodi/" style="color:#34d399; text-decoration:none;">Daniel Odi</a> - Computer Engineering</li>
        <li><a href="https://www.linkedin.com/in/alyssapinnock/" style="color:#34d399; text-decoration:none;">Alyssa Pinnock</a> - Computer Engineering</li>
        <li><a href="https://www.linkedin.com/in/anna-b-craig/" style="color:#34d399; text-decoration:none;">Anna Craig</a> - Electrical Engineering</li>
        </ul>

        <h4 style="margin:14px 0 6px">Specific Project Goals:</h4>
        <ul style="margin:0 0 8px 18px">
        <li>Implement common RISC-V extensions alongside unique ISA extensions for side-channel mitigation (noise injection, boolean masking)</li>
        <li>Functionally verify our design through UVM by the end of the Fall 2025 semester</li>
        <li>Proceed through the full tapeout process, generating a GDS-II file for our RISC-V design on a 45nm process node</li>
        </ul>

        <h4 style="margin:14px 0 6px">Status</h4>
        <p>Cadence certification trainings are underway, along with the initial exploration of the baseline Ibex core.</p>

      `
    },
    popup:  { coverMode:"ratio", coverRatio:1, heightRatio:1.425, anchorTop:true, startOffsetY:0, offsetY:-80 }
  },

  { id:"p3", r:1, c:2, label:"FPGA\nTrojan\nDesign", kind:"PROJ",
    content: {
      type:"html",
      html: `
        <h3 style="margin:0 0 8px">FPGA-based Custom Hardware Trojan</h3>
        <p>Instructional prototype to study stealthy trigger logic and payload behavior in a controlled environment.</p>

        <h4 style="margin:14px 0 6px">Scope &amp; threat model</h4>
        <ul style="margin:0 0 8px 18px">
          <li>Evaluates detection difficulty vs. resource footprint</li>
          <li>Explores rare-event triggers and side-channel signatures</li>
        </ul>

        <h4 style="margin:14px 0 6px">Ethics &amp; controls</h4>
        <p>Project conducted for defensive research and education with strict containment and review.</p>
      `
    },
    popup:  { coverMode:"ratio", coverRatio:1, heightRatio:1.425, anchorTop:true, startOffsetY:0, offsetY:-80 }
  },

  { id:"p4", r:1, c:1, label:"Cache\nCoherency\nAttack", kind:"PROJ",
    content: {
      type:"html",
      html: `
        <h3 style="margin:0 0 8px">Full-System Cache Coherency Attack Implementation in gem5</h3>
        <p>This project was a lab experiemnt from my Hardware Security and Trusted Circuit Design course at UCF, taught by Dr. Fan Yao.
            It saw us successfully simulating a system with a multi-level cache in gem5, utilizing attacker and victim threads in order to \
            encode data for secret transmission through the clever manipulation of cache coherency states when accessing specifically profiled \
            memory addresses.
            </p>



        <h4 style="margin:14px 0 6px">Mechanism</h4>
        <ul style="margin:0 0 8px 18px">
          <li>Prime/probe style access patterns over shared structures</li>
          <li>Noise mitigation and repeatability techniques</li>
        </ul>

        <h4 style="margin:14px 0 6px">Evaluation</h4>
        <p>Reproduced signals on FPGA-based prototypes and cycle-accurate sims; compared impact of line size and policy variants.</p>
      `
    },
    popup:  { coverMode:"ratio", coverRatio:1, heightRatio:1.425, anchorTop:true, startOffsetY:0, offsetY:-80 }
  },

  { id:"p5", r:0, c:2, label:"Range-\nFinder\nPCB\nDesign", kind:"PROJ",
    content: {
      type:"html",
      html: `
        <h3 style="margin:0 0 8px">Range-Finder PCB Design</h3>
        <p>Custom PCB integrating MCU, sensor front-end, and power regulation for a compact distance-measurement device.</p>

        <h4 style="margin:14px 0 6px">Design overview</h4>
        <ul style="margin:0 0 8px 18px">
          <li>Mixed-signal layout with ground partitioning</li>
          <li>Low-noise power and decoupling strategy</li>
          <li>Enclosure-aware connector placement</li>
        </ul>

        <h4 style="margin:14px 0 6px">Results</h4>
        <p>Successful bring-up with stable readings; firmware supports calibration and data logging.</p>
      `
    },
    popup:  { coverMode:"ratio", coverRatio:1, heightRatio:1.425, anchorTop:true, startOffsetY:0, offsetY:-80 }
  },

  { id:"involvement", r:2, c:0, label:"Clubs\n&\nActivities", kind:"IO",
    content: {
      type:"html",
      html: `
        <h3 style="margin:0 0 8px">Clubs &amp; Activities</h3>
        <p>Active within UCF’s engineering community with a focus on mentorship and events.</p>

        <h4 style="margin:14px 0 6px">Organizations</h4>
        <ul style="margin:0 0 8px 18px">
          <li>IEEE, ACM, KnightHacks</li>
          <li>IEEE HKN (Eta Kappa Nu) Honor Society</li>
        </ul>

        <h4 style="margin:14px 0 6px">What I do</h4>
        <ul style="margin:0 0 0 18px">
          <li>Peer mentorship (HDL basics, tooling)</li>
          <li>Event organizing and workshop content</li>
        </ul>
      `
    },
    popup:  { coverMode:"ratio", coverRatio:1, heightRatio:1.425, anchorTop:true, startOffsetY:0, offsetY:-80 }
  },

  { id:"skills", r:3, c:1, label:"My\nSkills", kind:"IO",
    content: {
      type:"html",
      html: `
        <h3 style="margin:0 0 8px">Skills</h3>
        <p>Tooling and languages I use day-to-day across architecture, RTL, and research.</p>

        <h4 style="margin:14px 0 6px">Languages &amp; HDLs</h4>
        <ul style="margin:0 0 8px 18px">
          <li>SystemVerilog, Verilog, VHDL</li>
          <li>C/C++, Python</li>
        </ul>

        <h4 style="margin:14px 0 6px">Tools &amp; Flows</h4>
        <ul style="margin:0 0 8px 18px">
          <li>FPGA toolchains, timing closure, floorplanning</li>
          <li>UVM verification, waveform/debug suites</li>
          <li>gem5 and architecture simulators</li>
        </ul>

        <h4 style="margin:14px 0 6px">Focus areas</h4>
        <ul style="margin:0 0 0 18px">
          <li>Computer architecture, VLSI design, hardware security</li>
          <li>Acceleration and reliability (ECC/SECDED)</li>
        </ul>
      `
    },
    popup:  { coverMode:"ratio", coverRatio:1, heightRatio:1.425, anchorTop:true, startOffsetY:0, offsetY:-80 }
  },

  { id:"courses", r:3, c:3, label:"Relevant\nCourses", kind:"IO",
    content: {
      type:"html",
      html: `
        <h3 style="margin:0 0 8px">Relevant Courses</h3>
        <p>Coursework supporting my focus on computer architecture and digital design.</p>

        <h4 style="margin:14px 0 6px">Core</h4>
        <ul style="margin:0 0 8px 18px">
          <li>Digital Systems (Intro to Digital Logic Design)</li>
          <li>Computer Organization</li>
          <li>Computer Architecture</li>
          <li>Computer Communications Networks</li>
          <li>Computer Science I/II</li>
          <li>Linear Circuits I/II</li>
          <li>Electronics I</li>
        </ul>

        <h4 style="margin:14px 0 6px">AdvancedElectives</h4>
        <ul style="margin:0 0 0 18px">
          <li>Advanced Computer Architecture (Graduate)</li>
          <li>Hardware Security and Trusted Circuit Design</li>
          <li>FPGA Design (Graduate)</li>
          <li>Advanced Verification and Validation of Digital Systems</li>
          <li>Hardware Description Languages</li>
          <li>Digital Signal Processing</li>
        </ul>
      `
    },
    popup:  { coverMode:"ratio", coverRatio:1, heightRatio:1.425, anchorTop:true, startOffsetY:0, offsetY:-80 }
  },
];


    const links = [
      {for:"resume", to:"About Me"},
      {for:"research", to:"About Me"},
      {for:"intern", to:"About Me"},
      {for:"website", to:"About Me"},
      {for:"involvement", to:"About Me"},

      {for:"Projects", to:"p1"},
      {for:"Projects", to:"p2"},
      {for:"Projects", to:"p3"},
      {for:"Projects", to:"p4"},
      {for:"Projects", to:"p5"},

      {for:"research", to:"eFPGA"},
      {for:"research", to:"ZKPs"},

      {for:"About Me", to: "courses"},
      {for:"About Me", to: "skills"},
      {for:"About Me", to: "Projects"},

      {for:"intern", to:"NG"},
    ];

    function App(){ return <FPGAHome rows={5} cols={5} tiles={tiles} links={links}/>; }
    const root = ReactDOM.createRoot(document.getElementById("root"));
    root.render(<App/>);
  </script>
</body>
</html>

